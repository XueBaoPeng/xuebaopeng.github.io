(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{320:function(a,t,s){a.exports=s.p+"assets/img/java-yunxinshishujuqu-Jdk1.7.ca90050e.png"},321:function(a,t,s){a.exports=s.p+"assets/img/java-yunxinshishujuqu-Jdk1.8.fd8a7270.png"},322:function(a,t,s){a.exports=s.p+"assets/img/jvm-duineicun-jdk7.fc113398.jpg"},323:function(a,t,s){a.exports=s.p+"assets/img/jvm-duineicun-jdk8.f9cb4328.jpg"},369:function(a,t,s){"use strict";s.r(t);var r=s(0),n=Object(r.a)({},(function(){var a=this,t=a.$createElement,r=a._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[r("div",{staticClass:"custom-block tip"},[r("ul",[r("li",[a._v("介绍下 Java 内存区域（运行时数据区）*")]),a._v(" "),r("li",[a._v("Java 对象的创建过程（五步，建议能默写出来并且要知道每一步虚拟机做了什么）")]),a._v(" "),r("li",[a._v("对象的访问定位的两种方式（句柄和直接指针两种方式）")])]),a._v(" "),r("ul",[r("li",[a._v("String 类和常量池")]),a._v(" "),r("li",[a._v("8 种基本类型的包装类和常量池")])])]),a._v(" "),r("h2",{attrs:{id:"一概述"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#一概述"}},[a._v("#")]),a._v(" 一概述")]),a._v(" "),r("p",[a._v("​          对于 Java 程序员来说，在虚拟机自动内存管理机制下，不再需要像 C/C++程序开发程序员这样为每一个 new 操作去写对应的 delete/free 操作，不容易出现内存泄漏和内存溢出问题。正是因为 Java 程序员把内存控制权利交给 Java 虚拟机，一旦出现内存泄漏和溢出方面的问题，如果不了解虚拟机是怎样使用内存的，那么排查错误将会是一个非常艰巨的任务。")]),a._v(" "),r("h2",{attrs:{id:"二-运行时数据区域"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#二-运行时数据区域"}},[a._v("#")]),a._v(" 二 运行时数据区域")]),a._v(" "),r("p",[a._v("​    Java 虚拟机在执行 Java 程序的过程中会把它管理的内存划分成若干个不同的数据区域。JDK. 1.8 和之前的版本略有不同，下面会介绍到")]),a._v(" "),r("p",[r("strong",[a._v("JDK 1.8 之前：")]),a._v(" "),r("img",{attrs:{src:s(320),alt:"SocksCap64.png"}})]),a._v(" "),r("p",[r("strong",[a._v("JDK 1.8 ：")])]),a._v(" "),r("p",[r("img",{attrs:{src:s(321),alt:"SocksCap64.png"}})]),a._v(" "),r("p",[a._v("线程私有的：")]),a._v(" "),r("ul",[r("li",[a._v("程序计数器")]),a._v(" "),r("li",[a._v("虚拟机栈")]),a._v(" "),r("li",[a._v("本地方法栈")])]),a._v(" "),r("h3",{attrs:{id:"_2-1程序计数器"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-1程序计数器"}},[a._v("#")]),a._v(" 2.1程序计数器")]),a._v(" "),r("p",[a._v("程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，\n分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完成。")]),a._v(" "),r("p",[a._v("另外，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。\n从上面的介绍中我们知道程序计数器主要有两个作用：")]),a._v(" "),r("p",[a._v("字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。\n在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。")]),a._v(" "),r("p",[a._v("注意：程序计数器是唯一一个不会出现 OutOfMemoryError 的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。")]),a._v(" "),r("h3",{attrs:{id:"_2-2-java虚拟机栈"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-java虚拟机栈"}},[a._v("#")]),a._v(" 2.2 Java虚拟机栈")]),a._v(" "),r("p",[a._v("与程序计数器一样，Java 虚拟机栈也是线程私有的，它的生命周期和线程相同，描述的是 Java 方法执行的内存模型，每次方法调用的数据都是通过栈传递的。")]),a._v(" "),r("p",[a._v("Java 内存可以粗糙的区分为堆内存（Heap）和栈内存 (Stack),其中栈就是现在说的虚拟机栈，或者说是虚拟机栈中局部变量表部分。 （实际上，Java 虚拟机栈是由一个个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法出口信息。）")]),a._v(" "),r("p",[a._v("局部变量表主要存放了编译器可知的各种数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference 类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。")]),a._v(" "),r("p",[a._v("Java 虚拟机栈会出现两种错误：StackOverFlowError 和 OutOfMemoryError。")]),a._v(" "),r("p",[a._v("StackOverFlowError： 若 Java 虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 StackOverFlowError 错误。\nOutOfMemoryError： 若 Java 虚拟机栈的内存大小允许动态扩展，且当线程请求栈时内存用完了，无法再动态扩展了，此时抛出 OutOfMemoryError 错误。\nJava 虚拟机栈也是线程私有的，每个线程都有各自的 Java 虚拟机栈，而且随着线程的创建而创建，随着线程的死亡而死亡。")]),a._v(" "),r("p",[a._v("扩展：那么方法/函数如何调用？")]),a._v(" "),r("p",[a._v("Java 栈可用类比数据结构中栈，Java 栈中保存的主要内容是栈帧，每一次函数调用都会有一个对应的栈帧被压入 Java 栈，每一个函数调用结束后，都会有一个栈帧被弹出。")]),a._v(" "),r("p",[a._v("Java 方法有两种返回方式：")]),a._v(" "),r("p",[a._v("return 语句。\n抛出异常。\n不管哪种返回方式都会导致栈帧被弹出。")]),a._v(" "),r("h3",{attrs:{id:"_2-3本地方法栈"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-3本地方法栈"}},[a._v("#")]),a._v(" 2.3本地方法栈")]),a._v(" "),r("p",[a._v("和虚拟机栈所发挥的作用非常相似，区别是： 虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。")]),a._v(" "),r("p",[a._v("本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。")]),a._v(" "),r("p",[a._v("方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现 StackOverFlowError 和 OutOfMemoryError 两种错误。")]),a._v(" "),r("h3",{attrs:{id:"_2-4堆"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-4堆"}},[a._v("#")]),a._v(" 2.4堆")]),a._v(" "),r("p",[a._v("Java 虚拟机所管理的内存中最大的一块，Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。")]),a._v(" "),r("p",[a._v("Java 堆是垃圾收集器管理的主要区域，因此也被称作GC 堆（Garbage Collected Heap）.从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以 Java 堆还可以细分为：新生代和老年代：再细致一点有：Eden 空间、From Survivor、To Survivor 空间等。进一步划分的目的是更好地回收内存，或者更快地分配内存。")]),a._v(" "),r("p",[a._v("在 JDK 7 版本及JDK 7 版本之前，堆内存被通常被分为下面三部分：")]),a._v(" "),r("ol",[r("li",[a._v("新生代内存(Young Generation)")]),a._v(" "),r("li",[a._v("老生代(Old Generation)")]),a._v(" "),r("li",[a._v("永生代(Permanent Generation)")])]),a._v(" "),r("p",[r("img",{attrs:{src:s(322),alt:"SocksCap64.png"}})]),a._v(" "),r("p",[a._v("JDK 8 版本之后方法区（HotSpot 的永久代）被彻底移除了（JDK1.7 就已经开始了），取而代之是元空间，元空间使用的是直接内存。")]),a._v(" "),r("p",[r("img",{attrs:{src:s(323),alt:"SocksCap64.png"}})]),a._v(" "),r("p",[a._v("上图所示的 Eden 区、两个 Survivor 区都属于新生代（为了区分，这两个 Survivor 区域按照顺序被命名为 from 和 to），中间一层属于老年代。")]),a._v(" "),r("p",[a._v("大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 s0 或者 s1，并且对象的年龄还会加 1(Eden 区->Survivor 区后对象的初始年龄变为 1)，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 -XX:MaxTenuringThreshold 来设置。")]),a._v(" "),r("div",{staticClass:"custom-block tip"},[r("p",[a._v("修正（issue552）：“Hotspot遍历所有对象时，按照年龄从小到大对其所占用的大小进行累积，当累积的某个年龄大小超过了survivor区的一半时，取这个年龄和MaxTenuringThreshold中更小的一个值，作为新的晋升年龄阈值”。\n动态年龄计算的代码如下")]),a._v(" "),r("div",{staticClass:"language-js line-numbers-mode"},[r("pre",{pre:!0,attrs:{class:"language-js"}},[r("code",[a._v("uint ageTable"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(":")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(":")]),r("span",{pre:!0,attrs:{class:"token function"}},[a._v("compute_tenuring_threshold")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),r("span",{pre:!0,attrs:{class:"token parameter"}},[a._v("size_t survivor_capacity")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),r("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n    "),r("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//survivor_capacity是survivor空间的大小")]),a._v("\n  size_t desired_survivor_size "),r("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),r("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("size_t"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("double"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" survivor_capacity"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),r("span",{pre:!0,attrs:{class:"token operator"}},[a._v("*")]),a._v("TargetSurvivorRatio"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),r("span",{pre:!0,attrs:{class:"token operator"}},[a._v("/")]),r("span",{pre:!0,attrs:{class:"token number"}},[a._v("100")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n  size_t total "),r("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),r("span",{pre:!0,attrs:{class:"token number"}},[a._v("0")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n  uint age "),r("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),r("span",{pre:!0,attrs:{class:"token number"}},[a._v("1")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n  "),r("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("while")]),a._v(" "),r("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("age "),r("span",{pre:!0,attrs:{class:"token operator"}},[a._v("<")]),a._v(" table_size"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),r("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n    total "),r("span",{pre:!0,attrs:{class:"token operator"}},[a._v("+=")]),a._v(" sizes"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),a._v("age"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),r("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//sizes数组是每个年龄段对象大小")]),a._v("\n    "),r("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("if")]),a._v(" "),r("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("total "),r("span",{pre:!0,attrs:{class:"token operator"}},[a._v(">")]),a._v(" desired_survivor_size"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),r("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("break")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    age"),r("span",{pre:!0,attrs:{class:"token operator"}},[a._v("++")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n  "),r("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n  uint result "),r("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" age "),r("span",{pre:!0,attrs:{class:"token operator"}},[a._v("<")]),a._v(" MaxTenuringThreshold "),r("span",{pre:!0,attrs:{class:"token operator"}},[a._v("?")]),a._v(" age "),r("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(":")]),a._v(" MaxTenuringThreshold"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    "),r("span",{pre:!0,attrs:{class:"token operator"}},[a._v("...")]),a._v("\n"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n\n")])]),a._v(" "),r("div",{staticClass:"line-numbers-wrapper"},[r("span",{staticClass:"line-number"},[a._v("1")]),r("br"),r("span",{staticClass:"line-number"},[a._v("2")]),r("br"),r("span",{staticClass:"line-number"},[a._v("3")]),r("br"),r("span",{staticClass:"line-number"},[a._v("4")]),r("br"),r("span",{staticClass:"line-number"},[a._v("5")]),r("br"),r("span",{staticClass:"line-number"},[a._v("6")]),r("br"),r("span",{staticClass:"line-number"},[a._v("7")]),r("br"),r("span",{staticClass:"line-number"},[a._v("8")]),r("br"),r("span",{staticClass:"line-number"},[a._v("9")]),r("br"),r("span",{staticClass:"line-number"},[a._v("10")]),r("br"),r("span",{staticClass:"line-number"},[a._v("11")]),r("br"),r("span",{staticClass:"line-number"},[a._v("12")]),r("br"),r("span",{staticClass:"line-number"},[a._v("13")]),r("br"),r("span",{staticClass:"line-number"},[a._v("14")]),r("br")])]),r("p",[a._v("堆这里最容易出现的就是 OutOfMemoryError 错误，并且出现这种错误之后的表现形式还会有几种，比如：")]),a._v(" "),r("ol",[r("li",[a._v("OutOfMemoryError: GC Overhead Limit Exceeded ： 当JVM花太多时间执行垃圾回收并且只能回收很少的堆空间时，就会发生此错误。")]),a._v(" "),r("li",[a._v("java.lang.OutOfMemoryError: Java heap space :假如在创建新的对象时, 堆内存中的空间不足以存放新创建的对象, 就会引发java.lang.OutOfMemoryError: Java heap space 错误。(和本机物理内存无关，和你配置的对内存大小有关！)")])])]),a._v(" "),r("h3",{attrs:{id:"_2-5方法区"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-5方法区"}},[a._v("#")]),a._v(" 2.5方法区")]),a._v(" "),r("p",[a._v("方法区与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然 Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做 Non-Heap（非堆），目的应该是与 Java 堆区分开来。")]),a._v(" "),r("p",[a._v("方法区也被称为永久代。很多人都会分不清方法区和永久代的关系，为此我也查阅了文献。")])])}),[],!1,null,null,null);t.default=n.exports}}]);